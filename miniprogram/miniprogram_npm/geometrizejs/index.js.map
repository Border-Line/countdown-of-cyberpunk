{"version":3,"sources":["index.js","geometrize.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar geometrize = require('./geometrize').geometrize;\nexports.ImageRunner = geometrize.runner.ImageRunner;\nexports.Bitmap = geometrize.bitmap.Bitmap;\nexports.ShapeTypes = geometrize.shape.ShapeTypes;\nexports.SvgExporter = geometrize.exporter.SvgExporter;\nexports.ShapeJsonExporter = geometrize.exporter.ShapeJsonExporter;\n//# sourceMappingURL=index.js.map","/*! \nThe MIT License (MIT)\n\nGeometrize Haxe is copyright (c) 2017 Sam Twidale (http://samcodes.co.uk/)\nBased on the Primitive library, copyright (c) 2016 Michael Fogleman (https://github.com/fogleman/primitive)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// @ts-nocheck\n// Generated by Haxe 3.4.7\n(function ($hx_exports, $global) { \n$hx_exports[\"geometrize\"] = $hx_exports[\"geometrize\"] || {};\n$hx_exports[\"geometrize\"][\"shape\"] = $hx_exports[\"geometrize\"][\"shape\"] || {};\n;$hx_exports[\"geometrize\"][\"runner\"] = $hx_exports[\"geometrize\"][\"runner\"] || {};\n;$hx_exports[\"geometrize\"][\"exporter\"] = $hx_exports[\"geometrize\"][\"exporter\"] || {};\n;$hx_exports[\"geometrize\"][\"bitmap\"] = $hx_exports[\"geometrize\"][\"bitmap\"] || {};\nfunction $extend(from, fields) {\n\tfunction Inherit() {} Inherit.prototype = from; var proto = new Inherit();\n\tfor (var name in fields) proto[name] = fields[name];\n\tif( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;\n\treturn proto;\n}\nvar HxOverrides = function() { };\nHxOverrides.__name__ = true;\nHxOverrides.remove = function(a,obj) {\n\tvar i = a.indexOf(obj);\n\tif(i == -1) {\n\t\treturn false;\n\t}\n\ta.splice(i,1);\n\treturn true;\n};\nHxOverrides.iter = function(a) {\n\treturn { cur : 0, arr : a, hasNext : function() {\n\t\treturn this.cur < this.arr.length;\n\t}, next : function() {\n\t\treturn this.arr[this.cur++];\n\t}};\n};\nMath.__name__ = true;\nvar Std = function() { };\nStd.__name__ = true;\nStd.string = function(s) {\n\treturn js_Boot.__string_rec(s,\"\");\n};\nStd.random = function(x) {\n\tif(x <= 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn Math.floor(Math.random() * x);\n\t}\n};\nvar StringTools = function() { };\nStringTools.__name__ = true;\nStringTools.replace = function(s,sub,by) {\n\treturn s.split(sub).join(by);\n};\nvar _$UInt_UInt_$Impl_$ = {};\n_$UInt_UInt_$Impl_$.__name__ = true;\n_$UInt_UInt_$Impl_$.toFloat = function(this1) {\n\tvar $int = this1;\n\tif($int < 0) {\n\t\treturn 4294967296.0 + $int;\n\t} else {\n\t\treturn $int + 0.0;\n\t}\n};\nvar geometrize_AbstractEnumTools = function() { };\ngeometrize_AbstractEnumTools.__name__ = true;\nvar geometrize__$ArraySet_ArraySet_$Impl_$ = {};\ngeometrize__$ArraySet_ArraySet_$Impl_$.__name__ = true;\ngeometrize__$ArraySet_ArraySet_$Impl_$.create = function(array) {\n\tif(array == null) {\n\t\tvar this1 = [];\n\t\treturn this1;\n\t}\n\treturn geometrize__$ArraySet_ArraySet_$Impl_$.toSet(array);\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.intersection = function(this1,set) {\n\tvar result = [];\n\tvar _g = 0;\n\twhile(_g < this1.length) {\n\t\tvar element = this1[_g];\n\t\t++_g;\n\t\tif(geometrize__$ArraySet_ArraySet_$Impl_$.contains(set,element)) {\n\t\t\tresult.push(element);\n\t\t}\n\t}\n\tvar this2 = result;\n\treturn this2;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.union = function(this1,set) {\n\treturn geometrize__$ArraySet_ArraySet_$Impl_$.toSet(this1.concat(geometrize__$ArraySet_ArraySet_$Impl_$.toArray(set)));\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.unionArray = function(this1,array) {\n\treturn geometrize__$ArraySet_ArraySet_$Impl_$.toSet(this1.concat(array));\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.difference = function(this1,set) {\n\tvar this2 = this1.slice();\n\tvar result = this2;\n\tvar element = HxOverrides.iter(set);\n\twhile(element.hasNext()) {\n\t\tvar element1 = element.next();\n\t\tHxOverrides.remove(result,element1);\n\t}\n\tvar this3 = geometrize__$ArraySet_ArraySet_$Impl_$.toArray(result);\n\treturn this3;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.add = function(this1,element) {\n\tif(!(element != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: element != null\");\n\t}\n\tif(geometrize__$ArraySet_ArraySet_$Impl_$.contains(this1,element)) {\n\t\treturn false;\n\t}\n\tthis1.push(element);\n\treturn true;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.contains = function(this1,element) {\n\tvar _g = 0;\n\twhile(_g < this1.length) {\n\t\tvar i = this1[_g];\n\t\t++_g;\n\t\tif(i == element) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.copy = function(this1) {\n\tvar this2 = this1.slice();\n\treturn this2;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.slice = function(this1,position,end) {\n\tvar this2 = this1.slice(position,end);\n\treturn this2;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.splice = function(this1,position,length) {\n\tvar this2 = this1.splice(position,length);\n\treturn this2;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.toArray = function(this1) {\n\treturn this1.slice();\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$.toSet = function(array) {\n\tvar this1 = [];\n\tvar set = this1;\n\tvar _g = 0;\n\twhile(_g < array.length) {\n\t\tvar v = array[_g];\n\t\t++_g;\n\t\tgeometrize__$ArraySet_ArraySet_$Impl_$.add(set,v);\n\t}\n\treturn set;\n};\ngeometrize__$ArraySet_ArraySet_$Impl_$._new = function(array) {\n\tvar this1 = array;\n\treturn this1;\n};\nvar geometrize_Core = function() { };\ngeometrize_Core.__name__ = true;\ngeometrize_Core.computeColor = function(target,current,lines,alpha) {\n\tif(!(target != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: target != null\");\n\t}\n\tif(!(current != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: current != null\");\n\t}\n\tif(!(lines != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lines != null\");\n\t}\n\tif(!(alpha >= 0)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: alpha >= 0\");\n\t}\n\tvar totalRed = 0;\n\tvar totalGreen = 0;\n\tvar totalBlue = 0;\n\tvar count = 0;\n\tvar f = 65535 / alpha;\n\tvar a = f | 0;\n\tvar _g = 0;\n\twhile(_g < lines.length) {\n\t\tvar line = lines[_g];\n\t\t++_g;\n\t\tvar y = line.y;\n\t\tvar _g2 = line.x1;\n\t\tvar _g1 = line.x2 + 1;\n\t\twhile(_g2 < _g1) {\n\t\t\tvar x = _g2++;\n\t\t\tvar t = target.data[target.width * y + x];\n\t\t\tvar c = current.data[current.width * y + x];\n\t\t\ttotalRed += ((t >> 24 & 255) - (c >> 24 & 255)) * a + (c >> 24 & 255) * 257;\n\t\t\ttotalGreen += ((t >> 16 & 255) - (c >> 16 & 255)) * a + (c >> 16 & 255) * 257;\n\t\t\ttotalBlue += ((t >> 8 & 255) - (c >> 8 & 255)) * a + (c >> 8 & 255) * 257;\n\t\t\t++count;\n\t\t}\n\t}\n\tif(count == 0) {\n\t\treturn 0;\n\t}\n\tvar value = (totalRed / count | 0) >> 8;\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tvar r = value < 0 ? 0 : value > 255 ? 255 : value;\n\tvar value1 = (totalGreen / count | 0) >> 8;\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tvar g = value1 < 0 ? 0 : value1 > 255 ? 255 : value1;\n\tvar value2 = (totalBlue / count | 0) >> 8;\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tvar b = value2 < 0 ? 0 : value2 > 255 ? 255 : value2;\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\treturn ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);\n};\ngeometrize_Core.differenceFull = function(first,second) {\n\tif(!(first != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: first != null\");\n\t}\n\tif(!(second != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: second != null\");\n\t}\n\tvar actual = first.width;\n\tvar expected = second.width;\n\tif(actual != expected) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: values are not equal (expected: \" + expected + \", actual: \" + actual + \")\");\n\t}\n\tvar actual1 = first.height;\n\tvar expected1 = second.height;\n\tif(actual1 != expected1) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: values are not equal (expected: \" + expected1 + \", actual: \" + actual1 + \")\");\n\t}\n\tvar total = 0;\n\tvar width = first.width;\n\tvar height = first.height;\n\tvar _g1 = 0;\n\tvar _g = height;\n\twhile(_g1 < _g) {\n\t\tvar y = _g1++;\n\t\tvar _g3 = 0;\n\t\tvar _g2 = width;\n\t\twhile(_g3 < _g2) {\n\t\t\tvar x = _g3++;\n\t\t\tvar f = first.data[first.width * y + x];\n\t\t\tvar s = second.data[second.width * y + x];\n\t\t\tvar dr = (f >> 24 & 255) - (s >> 24 & 255);\n\t\t\tvar dg = (f >> 16 & 255) - (s >> 16 & 255);\n\t\t\tvar db = (f >> 8 & 255) - (s >> 8 & 255);\n\t\t\tvar da = (f & 255) - (s & 255);\n\t\t\ttotal += dr * dr + dg * dg + db * db + da * da;\n\t\t}\n\t}\n\treturn Math.sqrt(total / (width * height * 4.0)) / 255;\n};\ngeometrize_Core.differencePartial = function(target,before,after,score,lines) {\n\tif(!(target != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: target != null\");\n\t}\n\tif(!(before != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: before != null\");\n\t}\n\tif(!(after != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: after != null\");\n\t}\n\tif(!(lines != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lines != null\");\n\t}\n\tvar width = target.width;\n\tvar height = target.height;\n\tvar rgbaCount = width * height * 4;\n\tvar total = Math.pow(score * 255,2) * rgbaCount;\n\tvar _g = 0;\n\twhile(_g < lines.length) {\n\t\tvar line = lines[_g];\n\t\t++_g;\n\t\tvar y = line.y;\n\t\tvar _g2 = line.x1;\n\t\tvar _g1 = line.x2 + 1;\n\t\twhile(_g2 < _g1) {\n\t\t\tvar x = _g2++;\n\t\t\tvar t = target.data[target.width * y + x];\n\t\t\tvar b = before.data[before.width * y + x];\n\t\t\tvar a = after.data[after.width * y + x];\n\t\t\tvar dtbr = (t >> 24 & 255) - (b >> 24 & 255);\n\t\t\tvar dtbg = (t >> 16 & 255) - (b >> 16 & 255);\n\t\t\tvar dtbb = (t >> 8 & 255) - (b >> 8 & 255);\n\t\t\tvar dtba = (t & 255) - (b & 255);\n\t\t\tvar dtar = (t >> 24 & 255) - (a >> 24 & 255);\n\t\t\tvar dtag = (t >> 16 & 255) - (a >> 16 & 255);\n\t\t\tvar dtab = (t >> 8 & 255) - (a >> 8 & 255);\n\t\t\tvar dtaa = (t & 255) - (a & 255);\n\t\t\ttotal -= dtbr * dtbr + dtbg * dtbg + dtbb * dtbb + dtba * dtba;\n\t\t\ttotal += dtar * dtar + dtag * dtag + dtab * dtab + dtaa * dtaa;\n\t\t}\n\t}\n\treturn Math.sqrt(total / rgbaCount) / 255;\n};\ngeometrize_Core.bestRandomState = function(shapes,alpha,n,target,current,buffer,lastScore) {\n\tvar bestEnergy = 0;\n\tvar bestState = null;\n\tvar _g1 = 0;\n\tvar _g = n;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tvar state = new geometrize_State(geometrize_shape_ShapeFactory.randomShapeOf(shapes,current.width,current.height),alpha,target,current,buffer);\n\t\tvar energy = state.energy(lastScore);\n\t\tif(i == 0 || energy < bestEnergy) {\n\t\t\tbestEnergy = energy;\n\t\t\tbestState = state;\n\t\t}\n\t}\n\treturn bestState;\n};\ngeometrize_Core.bestHillClimbState = function(shapes,alpha,n,age,target,current,buffer,lastScore) {\n\tvar state = geometrize_Core.bestRandomState(shapes,alpha,n,target,current,buffer,lastScore);\n\tstate = geometrize_Core.hillClimb(state,age,lastScore);\n\treturn state;\n};\ngeometrize_Core.hillClimb = function(state,maxAge,lastScore) {\n\tif(!(state != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: state != null\");\n\t}\n\tif(!(maxAge >= 0)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: maxAge >= 0\");\n\t}\n\tvar state1 = state.clone();\n\tvar bestState = state1.clone();\n\tvar bestEnergy = state1.energy(lastScore);\n\tvar age = 0;\n\twhile(age < maxAge) {\n\t\tvar undo = state1.mutate();\n\t\tvar energy = state1.energy(lastScore);\n\t\tif(energy >= bestEnergy) {\n\t\t\tstate1 = undo;\n\t\t} else {\n\t\t\tbestEnergy = energy;\n\t\t\tbestState = state1.clone();\n\t\t\tage = -1;\n\t\t}\n\t\t++age;\n\t}\n\treturn bestState;\n};\ngeometrize_Core.energy = function(shape,alpha,target,current,buffer,score) {\n\tif(!(shape != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: shape != null\");\n\t}\n\tif(!(target != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: target != null\");\n\t}\n\tif(!(current != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: current != null\");\n\t}\n\tif(!(buffer != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: buffer != null\");\n\t}\n\tvar lines = shape.rasterize();\n\tvar color = geometrize_Core.computeColor(target,current,lines,alpha);\n\tgeometrize_rasterizer_Rasterizer.copyLines(buffer,current,lines);\n\tgeometrize_rasterizer_Rasterizer.drawLines(buffer,color,lines);\n\treturn geometrize_Core.differencePartial(target,current,buffer,score,lines);\n};\nvar geometrize_Model = function(target,backgroundColor) {\n\tif(!(target != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: target != null\");\n\t}\n\tthis.width = target.width;\n\tthis.height = target.height;\n\tthis.target = target;\n\tvar w = target.width;\n\tvar h = target.height;\n\tvar bitmap = new geometrize_bitmap_Bitmap();\n\tbitmap.width = w;\n\tbitmap.height = h;\n\tvar this1 = new Array(w * h);\n\tbitmap.data = this1;\n\tvar i = 0;\n\twhile(i < bitmap.data.length) {\n\t\tbitmap.data[i] = backgroundColor;\n\t\t++i;\n\t}\n\tthis.current = bitmap;\n\tvar w1 = target.width;\n\tvar h1 = target.height;\n\tvar bitmap1 = new geometrize_bitmap_Bitmap();\n\tbitmap1.width = w1;\n\tbitmap1.height = h1;\n\tvar this2 = new Array(w1 * h1);\n\tbitmap1.data = this2;\n\tvar i1 = 0;\n\twhile(i1 < bitmap1.data.length) {\n\t\tbitmap1.data[i1] = backgroundColor;\n\t\t++i1;\n\t}\n\tthis.buffer = bitmap1;\n\tthis.score = geometrize_Core.differenceFull(target,this.current);\n};\ngeometrize_Model.__name__ = true;\ngeometrize_Model.prototype = {\n\tstep: function(shapeTypes,alpha,n,age) {\n\t\tvar state = geometrize_Core.bestHillClimbState(shapeTypes,alpha,n,age,this.target,this.current,this.buffer,this.score);\n\t\tvar results = [this.addShape(state.shape,state.alpha)];\n\t\treturn results;\n\t}\n\t,addShape: function(shape,alpha) {\n\t\tif(!(shape != null)) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: shape != null\");\n\t\t}\n\t\tvar _this = this.current;\n\t\tvar bitmap = new geometrize_bitmap_Bitmap();\n\t\tbitmap.width = _this.width;\n\t\tbitmap.height = _this.height;\n\t\tvar length = _this.data.length;\n\t\tvar this1 = new Array(length);\n\t\tbitmap.data = this1;\n\t\tvar _g1 = 0;\n\t\tvar _g = _this.data.length;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tbitmap.data[i] = _this.data[i];\n\t\t}\n\t\tvar before = bitmap;\n\t\tvar lines = shape.rasterize();\n\t\tvar color = geometrize_Core.computeColor(this.target,this.current,lines,alpha);\n\t\tgeometrize_rasterizer_Rasterizer.drawLines(this.current,color,lines);\n\t\tthis.score = geometrize_Core.differencePartial(this.target,before,this.current,this.score,lines);\n\t\tvar result = { score : this.score, color : color, shape : shape};\n\t\treturn result;\n\t}\n\t,__class__: geometrize_Model\n};\nvar geometrize_State = function(shape,alpha,target,current,buffer) {\n\tif(!(shape != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: shape != null\");\n\t}\n\tthis.shape = shape;\n\tthis.alpha = alpha;\n\tthis.score = -1;\n\tthis.target = target;\n\tthis.current = current;\n\tthis.buffer = buffer;\n};\ngeometrize_State.__name__ = true;\ngeometrize_State.prototype = {\n\tenergy: function(lastScore) {\n\t\tif(this.score < 0) {\n\t\t\tthis.score = geometrize_Core.energy(this.shape,this.alpha,this.target,this.current,this.buffer,lastScore);\n\t\t}\n\t\treturn this.score;\n\t}\n\t,mutate: function() {\n\t\tvar oldState = this.clone();\n\t\tthis.shape.mutate();\n\t\treturn oldState;\n\t}\n\t,clone: function() {\n\t\treturn new geometrize_State(this.shape.clone(),this.alpha,this.target,this.current,this.buffer);\n\t}\n\t,__class__: geometrize_State\n};\nvar geometrize_Util = function() { };\ngeometrize_Util.__name__ = true;\ngeometrize_Util.getAverageImageColor = function(image,alpha) {\n\tif(alpha == null) {\n\t\talpha = 255;\n\t}\n\tif(!(image != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: image != null\");\n\t}\n\tvar totalRed = 0;\n\tvar totalGreen = 0;\n\tvar totalBlue = 0;\n\tvar _g1 = 0;\n\tvar _g = image.width;\n\twhile(_g1 < _g) {\n\t\tvar x = _g1++;\n\t\tvar _g3 = 0;\n\t\tvar _g2 = image.height;\n\t\twhile(_g3 < _g2) {\n\t\t\tvar y = _g3++;\n\t\t\tvar pixel = image.data[image.width * y + x];\n\t\t\ttotalRed += pixel >> 24 & 255;\n\t\t\ttotalGreen += pixel >> 16 & 255;\n\t\t\ttotalBlue += pixel >> 8 & 255;\n\t\t}\n\t}\n\tvar size = image.width * image.height;\n\tvar red = totalRed / size | 0;\n\tvar green = totalGreen / size | 0;\n\tvar blue = totalBlue / size | 0;\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\treturn ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);\n};\ngeometrize_Util.clamp = function(value,min,max) {\n\tif(!(min <= max)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(value < min) {\n\t\treturn min;\n\t} else if(value > max) {\n\t\treturn max;\n\t} else {\n\t\treturn value;\n\t}\n};\ngeometrize_Util.min = function(first,second) {\n\tif(first < second) {\n\t\treturn first;\n\t} else {\n\t\treturn second;\n\t}\n};\ngeometrize_Util.max = function(first,second) {\n\tif(first > second) {\n\t\treturn first;\n\t} else {\n\t\treturn second;\n\t}\n};\ngeometrize_Util.toRadians = function(degrees) {\n\treturn degrees * Math.PI / 180;\n};\ngeometrize_Util.toDegrees = function(radians) {\n\treturn radians * 180 / Math.PI;\n};\ngeometrize_Util.random = function(lower,upper) {\n\tif(!(lower <= upper)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\treturn lower + Math.floor((upper - lower + 1) * Math.random());\n};\ngeometrize_Util.randomArrayItem = function(a) {\n\tif(!(a != null && a.length > 0)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: a != null && a.length > 0\");\n\t}\n\tvar upper = a.length - 1;\n\tif(!(0 <= upper)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\treturn a[Math.floor((upper + 1) * Math.random())];\n};\ngeometrize_Util.minMaxElements = function(a) {\n\tif(a == null || a.length == 0) {\n\t\treturn { x : 0, y : 0};\n\t}\n\tvar min = a[0];\n\tvar max = a[0];\n\tvar _g = 0;\n\twhile(_g < a.length) {\n\t\tvar value = a[_g];\n\t\t++_g;\n\t\tif(min > value) {\n\t\t\tmin = value;\n\t\t}\n\t\tif(max < value) {\n\t\t\tmax = value;\n\t\t}\n\t}\n\treturn { x : min, y : max};\n};\ngeometrize_Util.abs = function(value) {\n\tif(value < 0) {\n\t\treturn -value;\n\t}\n\treturn value;\n};\nvar geometrize_bitmap_Bitmap = $hx_exports[\"geometrize\"][\"bitmap\"][\"Bitmap\"] = function() {\n};\ngeometrize_bitmap_Bitmap.__name__ = true;\ngeometrize_bitmap_Bitmap.create = function(w,h,color) {\n\tvar bitmap = new geometrize_bitmap_Bitmap();\n\tbitmap.width = w;\n\tbitmap.height = h;\n\tvar this1 = new Array(w * h);\n\tbitmap.data = this1;\n\tvar i = 0;\n\twhile(i < bitmap.data.length) {\n\t\tbitmap.data[i] = color;\n\t\t++i;\n\t}\n\treturn bitmap;\n};\ngeometrize_bitmap_Bitmap.createFromBytes = function(w,h,bytes) {\n\tvar bitmap = new geometrize_bitmap_Bitmap();\n\tif(!(bytes != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: bytes != null\");\n\t}\n\tvar actual = bytes.length;\n\tvar expected = w * h * 4;\n\tif(actual != expected) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: values are not equal (expected: \" + expected + \", actual: \" + actual + \")\");\n\t}\n\tbitmap.width = w;\n\tbitmap.height = h;\n\tvar length = bytes.length / 4 | 0;\n\tvar this1 = new Array(length);\n\tbitmap.data = this1;\n\tvar i = 0;\n\tvar x = 0;\n\twhile(i < bytes.length) {\n\t\tvar red = bytes.b[i];\n\t\tvar green = bytes.b[i + 1];\n\t\tvar blue = bytes.b[i + 2];\n\t\tvar alpha = bytes.b[i + 3];\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tbitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);\n\t\ti += 4;\n\t\t++x;\n\t}\n\treturn bitmap;\n};\ngeometrize_bitmap_Bitmap.createFromByteArray = function(w,h,bytes) {\n\tvar data = new haxe_io_Bytes(new ArrayBuffer(bytes.length));\n\tvar i = 0;\n\twhile(i < bytes.length) {\n\t\tdata.b[i] = bytes[i] & 255;\n\t\t++i;\n\t}\n\tvar bitmap = new geometrize_bitmap_Bitmap();\n\tif(!(data != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: bytes != null\");\n\t}\n\tvar actual = data.length;\n\tvar expected = w * h * 4;\n\tif(actual != expected) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: values are not equal (expected: \" + expected + \", actual: \" + actual + \")\");\n\t}\n\tbitmap.width = w;\n\tbitmap.height = h;\n\tvar length = data.length / 4 | 0;\n\tvar this1 = new Array(length);\n\tbitmap.data = this1;\n\tvar i1 = 0;\n\tvar x = 0;\n\twhile(i1 < data.length) {\n\t\tvar red = data.b[i1];\n\t\tvar green = data.b[i1 + 1];\n\t\tvar blue = data.b[i1 + 2];\n\t\tvar alpha = data.b[i1 + 3];\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t}\n\t\tbitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);\n\t\ti1 += 4;\n\t\t++x;\n\t}\n\treturn bitmap;\n};\ngeometrize_bitmap_Bitmap.prototype = {\n\tgetPixel: function(x,y) {\n\t\treturn this.data[this.width * y + x];\n\t}\n\t,setPixel: function(x,y,color) {\n\t\tthis.data[this.width * y + x] = color;\n\t}\n\t,clone: function() {\n\t\tvar bitmap = new geometrize_bitmap_Bitmap();\n\t\tbitmap.width = this.width;\n\t\tbitmap.height = this.height;\n\t\tvar length = this.data.length;\n\t\tvar this1 = new Array(length);\n\t\tbitmap.data = this1;\n\t\tvar _g1 = 0;\n\t\tvar _g = this.data.length;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tbitmap.data[i] = this.data[i];\n\t\t}\n\t\treturn bitmap;\n\t}\n\t,fill: function(color) {\n\t\tvar idx = 0;\n\t\twhile(idx < this.data.length) {\n\t\t\tthis.data[idx] = color >> 24 & 255;\n\t\t\tthis.data[idx + 1] = color >> 16 & 255;\n\t\t\tthis.data[idx + 2] = color >> 8 & 255;\n\t\t\tthis.data[idx + 3] = color & 255;\n\t\t\tidx += 4;\n\t\t}\n\t}\n\t,getBytes: function() {\n\t\tvar bytes = new haxe_io_Bytes(new ArrayBuffer(this.data.length * 4));\n\t\tvar i = 0;\n\t\twhile(i < this.data.length) {\n\t\t\tvar idx = i * 4;\n\t\t\tbytes.b[idx] = this.data[i] >> 24 & 255 & 255;\n\t\t\tbytes.b[idx + 1] = this.data[i] >> 16 & 255 & 255;\n\t\t\tbytes.b[idx + 2] = this.data[i] >> 8 & 255 & 255;\n\t\t\tbytes.b[idx + 3] = this.data[i] & 255 & 255;\n\t\t\t++i;\n\t\t}\n\t\treturn bytes;\n\t}\n\t,__class__: geometrize_bitmap_Bitmap\n};\nvar geometrize_bitmap__$Rgba_Rgba_$Impl_$ = {};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.__name__ = true;\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$._new = function(rgba) {\n\tvar this1 = rgba;\n\treturn this1;\n};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.create = function(red,green,blue,alpha) {\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\treturn ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);\n};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.fromInt = function(rgba) {\n\treturn rgba;\n};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.get_r = function(this1) {\n\treturn this1 >> 24 & 255;\n};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.get_g = function(this1) {\n\treturn this1 >> 16 & 255;\n};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.get_b = function(this1) {\n\treturn this1 >> 8 & 255;\n};\ngeometrize_bitmap__$Rgba_Rgba_$Impl_$.get_a = function(this1) {\n\treturn this1 & 255;\n};\nvar geometrize_exporter_ShapeJsonExporter = $hx_exports[\"geometrize\"][\"exporter\"][\"ShapeJsonExporter\"] = function() { };\ngeometrize_exporter_ShapeJsonExporter.__name__ = true;\ngeometrize_exporter_ShapeJsonExporter[\"export\"] = function(shapes) {\n\treturn \"[\\n\" + geometrize_exporter_ShapeJsonExporter.exportShapes(shapes) + \"\\n]\";\n};\ngeometrize_exporter_ShapeJsonExporter.exportShapes = function(shapes) {\n\tvar results = \"\";\n\tvar _g1 = 0;\n\tvar _g = shapes.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tresults += geometrize_exporter_ShapeJsonExporter.exportShape(shapes[i]);\n\t\tif(i != shapes.length - 1) {\n\t\t\tresults += \"\\n\";\n\t\t}\n\t}\n\treturn results;\n};\ngeometrize_exporter_ShapeJsonExporter.exportShape = function(shape) {\n\tvar result = \"    {\\n\";\n\tvar type = shape.shape.getType();\n\tvar data = shape.shape.getRawShapeData();\n\tvar color = shape.color;\n\tvar score = shape.score;\n\tresult += \"        \\\"type\\\":\" + type + \",\\n\";\n\tresult += \"        \\\"data\\\":\" + \"[\";\n\tvar _g1 = 0;\n\tvar _g = data.length;\n\twhile(_g1 < _g) {\n\t\tvar item = _g1++;\n\t\tresult += data[item];\n\t\tif(item <= data.length - 2) {\n\t\t\tresult += \",\";\n\t\t}\n\t}\n\tresult += \"],\\n\";\n\tresult += \"        \\\"color\\\":\" + \"[\";\n\tresult += (color >> 24 & 255) + \",\";\n\tresult += (color >> 16 & 255) + \",\";\n\tresult += (color >> 8 & 255) + \",\";\n\tresult += color & 255;\n\tresult += \"],\\n\";\n\tresult += \"        \\\"score\\\":\" + score + \"\\n\";\n\tresult += \"    }\";\n\treturn result;\n};\nvar geometrize_exporter_SvgExporter = $hx_exports[\"geometrize\"][\"exporter\"][\"SvgExporter\"] = function() { };\ngeometrize_exporter_SvgExporter.__name__ = true;\ngeometrize_exporter_SvgExporter[\"export\"] = function(shapes,width,height) {\n\tvar results = geometrize_exporter_SvgExporter.getSvgPrelude();\n\tresults += geometrize_exporter_SvgExporter.getSvgNodeOpen(width,height);\n\tresults += geometrize_exporter_SvgExporter.exportShapes(shapes);\n\tresults += geometrize_exporter_SvgExporter.getSvgNodeClose();\n\treturn results;\n};\ngeometrize_exporter_SvgExporter.exportShapes = function(shapes) {\n\tvar results = \"\";\n\tvar _g1 = 0;\n\tvar _g = shapes.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tresults += geometrize_exporter_SvgExporter.exportShape(shapes[i]);\n\t\tif(i != shapes.length - 1) {\n\t\t\tresults += \"\\n\";\n\t\t}\n\t}\n\treturn results;\n};\ngeometrize_exporter_SvgExporter.exportShape = function(shape) {\n\treturn StringTools.replace(shape.shape.getSvgShapeData(),geometrize_exporter_SvgExporter.SVG_STYLE_HOOK,geometrize_exporter_SvgExporter.stylesForShape(shape));\n};\ngeometrize_exporter_SvgExporter.getSvgPrelude = function() {\n\treturn \"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?>\\n\";\n};\ngeometrize_exporter_SvgExporter.getSvgNodeOpen = function(width,height) {\n\treturn \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.2\\\" baseProfile=\\\"tiny\\\" width=\\\"\" + width + \"\\\" height=\\\"\" + height + \"\\\">\\n\";\n};\ngeometrize_exporter_SvgExporter.getSvgNodeClose = function() {\n\treturn \"</svg>\";\n};\ngeometrize_exporter_SvgExporter.stylesForShape = function(shape) {\n\tvar _g = shape.shape.getType();\n\tswitch(_g) {\n\tcase 6:case 7:\n\t\treturn geometrize_exporter_SvgExporter.strokeForColor(shape.color) + \" stroke-width=\\\"1\\\" fill=\\\"none\\\" \" + geometrize_exporter_SvgExporter.strokeOpacityForAlpha(shape.color & 255);\n\tdefault:\n\t\treturn geometrize_exporter_SvgExporter.fillForColor(shape.color) + \" \" + geometrize_exporter_SvgExporter.fillOpacityForAlpha(shape.color & 255);\n\t}\n};\ngeometrize_exporter_SvgExporter.rgbForColor = function(color) {\n\treturn \"rgb(\" + (color >> 24 & 255) + \",\" + (color >> 16 & 255) + \",\" + (color >> 8 & 255) + \")\";\n};\ngeometrize_exporter_SvgExporter.strokeForColor = function(color) {\n\treturn \"stroke=\\\"\" + geometrize_exporter_SvgExporter.rgbForColor(color) + \"\\\"\";\n};\ngeometrize_exporter_SvgExporter.fillForColor = function(color) {\n\treturn \"fill=\\\"\" + geometrize_exporter_SvgExporter.rgbForColor(color) + \"\\\"\";\n};\ngeometrize_exporter_SvgExporter.fillOpacityForAlpha = function(alpha) {\n\treturn \"fill-opacity=\\\"\" + alpha / 255.0 + \"\\\"\";\n};\ngeometrize_exporter_SvgExporter.strokeOpacityForAlpha = function(alpha) {\n\treturn \"stroke-opacity=\\\"\" + alpha / 255.0 + \"\\\"\";\n};\nvar geometrize_rasterizer_Rasterizer = function() { };\ngeometrize_rasterizer_Rasterizer.__name__ = true;\ngeometrize_rasterizer_Rasterizer.drawLines = function(image,c,lines) {\n\tif(!(image != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: image != null\");\n\t}\n\tif(!(lines != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lines != null\");\n\t}\n\tvar sr = c >> 24 & 255;\n\tsr |= sr << 8;\n\tsr *= c & 255;\n\tsr = sr / 255 | 0;\n\tvar sg = c >> 16 & 255;\n\tsg |= sg << 8;\n\tsg *= c & 255;\n\tsg = sg / 255 | 0;\n\tvar sb = c >> 8 & 255;\n\tsb |= sb << 8;\n\tsb *= c & 255;\n\tsb = sb / 255 | 0;\n\tvar sa = c & 255;\n\tsa |= sa << 8;\n\tvar _g = 0;\n\twhile(_g < lines.length) {\n\t\tvar line = lines[_g];\n\t\t++_g;\n\t\tvar y = line.y;\n\t\tvar ma = 65535;\n\t\tvar m = 65535;\n\t\tvar $as = (m - sa * (ma / m)) * 257;\n\t\tvar a = $as | 0;\n\t\tvar _g2 = line.x1;\n\t\tvar _g1 = line.x2 + 1;\n\t\twhile(_g2 < _g1) {\n\t\t\tvar x = _g2++;\n\t\t\tvar d = image.data[image.width * y + x];\n\t\t\tvar dr = d >> 24 & 255;\n\t\t\tvar dg = d >> 16 & 255;\n\t\t\tvar db = d >> 8 & 255;\n\t\t\tvar da = d & 255;\n\t\t\tvar r = (_$UInt_UInt_$Impl_$.toFloat(dr * a + sr * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;\n\t\t\tvar g = (_$UInt_UInt_$Impl_$.toFloat(dg * a + sg * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;\n\t\t\tvar b = (_$UInt_UInt_$Impl_$.toFloat(db * a + sb * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;\n\t\t\tvar a1 = (_$UInt_UInt_$Impl_$.toFloat(da * a + sa * ma) / _$UInt_UInt_$Impl_$.toFloat(m) | 0) >> 8;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\timage.data[image.width * y + x] = ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (a1 < 0 ? 0 : a1 > 255 ? 255 : a1);\n\t\t}\n\t}\n};\ngeometrize_rasterizer_Rasterizer.copyLines = function(destination,source,lines) {\n\tif(!(destination != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: destination != null\");\n\t}\n\tif(!(source != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: source != null\");\n\t}\n\tif(!(lines != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lines != null\");\n\t}\n\tvar _g = 0;\n\twhile(_g < lines.length) {\n\t\tvar line = lines[_g];\n\t\t++_g;\n\t\tvar y = line.y;\n\t\tvar _g2 = line.x1;\n\t\tvar _g1 = line.x2 + 1;\n\t\twhile(_g2 < _g1) {\n\t\t\tvar x = _g2++;\n\t\t\tdestination.data[destination.width * y + x] = source.data[source.width * y + x];\n\t\t}\n\t}\n};\ngeometrize_rasterizer_Rasterizer.bresenham = function(x1,y1,x2,y2) {\n\tvar dx = x2 - x1;\n\tvar ix = (dx > 0 ? 1 : 0) - (dx < 0 ? 1 : 0);\n\tdx = (dx < 0 ? -dx : dx) << 1;\n\tvar dy = y2 - y1;\n\tvar iy = (dy > 0 ? 1 : 0) - (dy < 0 ? 1 : 0);\n\tdy = (dy < 0 ? -dy : dy) << 1;\n\tvar points = [];\n\tpoints.push({ x : x1, y : y1});\n\tif(dx >= dy) {\n\t\tvar error = dy - (dx >> 1);\n\t\twhile(x1 != x2) {\n\t\t\tif(error >= 0 && (error != 0 || ix > 0)) {\n\t\t\t\terror -= dx;\n\t\t\t\ty1 += iy;\n\t\t\t}\n\t\t\terror += dy;\n\t\t\tx1 += ix;\n\t\t\tpoints.push({ x : x1, y : y1});\n\t\t}\n\t} else {\n\t\tvar error1 = dx - (dy >> 1);\n\t\twhile(y1 != y2) {\n\t\t\tif(error1 >= 0 && (error1 != 0 || iy > 0)) {\n\t\t\t\terror1 -= dy;\n\t\t\t\tx1 += ix;\n\t\t\t}\n\t\t\terror1 += dx;\n\t\t\ty1 += iy;\n\t\t\tpoints.push({ x : x1, y : y1});\n\t\t}\n\t}\n\treturn points;\n};\ngeometrize_rasterizer_Rasterizer.scanlinesForPolygon = function(points) {\n\tvar lines = [];\n\tvar edges = [];\n\tvar _g1 = 0;\n\tvar _g = points.length;\n\twhile(_g1 < _g) {\n\t\tvar i = _g1++;\n\t\tvar p1 = points[i];\n\t\tvar p2 = i == points.length - 1 ? points[0] : points[i + 1];\n\t\tvar p1p2 = geometrize_rasterizer_Rasterizer.bresenham(p1.x,p1.y,p2.x,p2.y);\n\t\tedges = edges.concat(p1p2);\n\t}\n\tvar yToXs = new haxe_ds_IntMap();\n\tvar _g2 = 0;\n\twhile(_g2 < edges.length) {\n\t\tvar point = edges[_g2];\n\t\t++_g2;\n\t\tvar s = yToXs.h[point.y];\n\t\tif(s != null) {\n\t\t\tgeometrize__$ArraySet_ArraySet_$Impl_$.add(s,point.x);\n\t\t} else {\n\t\t\ts = geometrize__$ArraySet_ArraySet_$Impl_$.create();\n\t\t\tgeometrize__$ArraySet_ArraySet_$Impl_$.add(s,point.x);\n\t\t\tyToXs.h[point.y] = s;\n\t\t}\n\t}\n\tvar key = yToXs.keys();\n\twhile(key.hasNext()) {\n\t\tvar key1 = key.next();\n\t\tvar a = geometrize__$ArraySet_ArraySet_$Impl_$.toArray(yToXs.h[key1]);\n\t\tvar minMaxElements;\n\t\tif(a == null || a.length == 0) {\n\t\t\tminMaxElements = { x : 0, y : 0};\n\t\t} else {\n\t\t\tvar min = a[0];\n\t\t\tvar max = a[0];\n\t\t\tvar _g3 = 0;\n\t\t\twhile(_g3 < a.length) {\n\t\t\t\tvar value = a[_g3];\n\t\t\t\t++_g3;\n\t\t\t\tif(min > value) {\n\t\t\t\t\tmin = value;\n\t\t\t\t}\n\t\t\t\tif(max < value) {\n\t\t\t\t\tmax = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tminMaxElements = { x : min, y : max};\n\t\t}\n\t\tlines.push(new geometrize_rasterizer_Scanline(key1,minMaxElements.x,minMaxElements.y));\n\t}\n\treturn lines;\n};\nvar geometrize_rasterizer_Scanline = function(y,x1,x2) {\n\tthis.y = y;\n\tthis.x1 = x1;\n\tthis.x2 = x2;\n};\ngeometrize_rasterizer_Scanline.__name__ = true;\ngeometrize_rasterizer_Scanline.trim = function(scanlines,w,h) {\n\tif(!(scanlines != null)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: scanlines != null\");\n\t}\n\tvar w1 = w;\n\tvar h1 = h;\n\treturn scanlines.filter(function(a1) {\n\t\treturn geometrize_rasterizer_Scanline.trimHelper(a1,w1,h1);\n\t});\n};\ngeometrize_rasterizer_Scanline.trimHelper = function(line,w,h) {\n\tif(line.y < 0 || line.y >= h || line.x1 >= w || line.x2 < 0) {\n\t\treturn false;\n\t}\n\tvar value = line.x1;\n\tvar max = w - 1;\n\tif(!(0 <= max)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tline.x1 = value < 0 ? 0 : value > max ? max : value;\n\tvar value1 = line.x2;\n\tvar max1 = w - 1;\n\tif(!(0 <= max1)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tline.x2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\treturn line.x1 <= line.x2;\n};\ngeometrize_rasterizer_Scanline.prototype = {\n\t__class__: geometrize_rasterizer_Scanline\n};\nvar geometrize_runner_ImageRunner = $hx_exports[\"geometrize\"][\"runner\"][\"ImageRunner\"] = function(inputImage,backgroundColor) {\n\tthis.model = null;\n\tthis.model = new geometrize_Model(inputImage,backgroundColor);\n};\ngeometrize_runner_ImageRunner.__name__ = true;\ngeometrize_runner_ImageRunner.prototype = {\n\tstep: function(options) {\n\t\treturn this.model.step(options.shapeTypes,options.alpha,options.candidateShapesPerStep,options.shapeMutationsPerStep);\n\t}\n\t,getImageData: function() {\n\t\tif(!(this.model != null)) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: model != null\");\n\t\t}\n\t\treturn this.model.current;\n\t}\n\t,__class__: geometrize_runner_ImageRunner\n};\nvar geometrize_shape_Shape = function() { };\ngeometrize_shape_Shape.__name__ = true;\ngeometrize_shape_Shape.prototype = {\n\t__class__: geometrize_shape_Shape\n};\nvar geometrize_shape_Ellipse = function(xBound,yBound) {\n\tthis.x = Std.random(xBound);\n\tthis.y = Std.random(yBound);\n\tthis.rx = Std.random(32) + 1;\n\tthis.ry = Std.random(32) + 1;\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_Ellipse.__name__ = true;\ngeometrize_shape_Ellipse.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_Ellipse.prototype = {\n\trasterize: function() {\n\t\tvar lines = [];\n\t\tvar aspect = this.rx / this.ry;\n\t\tvar w = this.xBound;\n\t\tvar h = this.yBound;\n\t\tvar _g1 = 0;\n\t\tvar _g = this.ry;\n\t\twhile(_g1 < _g) {\n\t\t\tvar dy = _g1++;\n\t\t\tvar y1 = this.y - dy;\n\t\t\tvar y2 = this.y + dy;\n\t\t\tif((y1 < 0 || y1 >= h) && (y2 < 0 || y2 >= h)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar s = Math.sqrt(this.ry * this.ry - dy * dy) * aspect | 0;\n\t\t\tvar x1 = this.x - s;\n\t\t\tvar x2 = this.x + s;\n\t\t\tif(x1 < 0) {\n\t\t\t\tx1 = 0;\n\t\t\t}\n\t\t\tif(x2 >= w) {\n\t\t\t\tx2 = w - 1;\n\t\t\t}\n\t\t\tif(y1 >= 0 && y1 < h) {\n\t\t\t\tlines.push(new geometrize_rasterizer_Scanline(y1,x1,x2));\n\t\t\t}\n\t\t\tif(y2 >= 0 && y2 < h && dy > 0) {\n\t\t\t\tlines.push(new geometrize_rasterizer_Scanline(y2,x1,x2));\n\t\t\t}\n\t\t}\n\t\treturn lines;\n\t}\n\t,mutate: function() {\n\t\tvar r = Std.random(3);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.rx + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(1 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.rx = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.ry + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max3 = this.xBound - 1;\n\t\t\tif(!(1 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.ry = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar ellipse = new geometrize_shape_Ellipse(this.xBound,this.yBound);\n\t\tellipse.x = this.x;\n\t\tellipse.y = this.y;\n\t\tellipse.rx = this.rx;\n\t\tellipse.ry = this.ry;\n\t\treturn ellipse;\n\t}\n\t,getType: function() {\n\t\treturn 3;\n\t}\n\t,getRawShapeData: function() {\n\t\treturn [this.x,this.y,this.rx,this.ry];\n\t}\n\t,getSvgShapeData: function() {\n\t\treturn \"<ellipse cx=\\\"\" + this.x + \"\\\" cy=\\\"\" + this.y + \"\\\" rx=\\\"\" + this.rx + \"\\\" ry=\\\"\" + this.ry + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \" />\";\n\t}\n\t,__class__: geometrize_shape_Ellipse\n};\nvar geometrize_shape_Circle = function(xBound,yBound) {\n\tgeometrize_shape_Ellipse.call(this,xBound,yBound);\n\tthis.rx = Std.random(32) + 1;\n\tthis.ry = this.rx;\n};\ngeometrize_shape_Circle.__name__ = true;\ngeometrize_shape_Circle.__super__ = geometrize_shape_Ellipse;\ngeometrize_shape_Circle.prototype = $extend(geometrize_shape_Ellipse.prototype,{\n\tmutate: function() {\n\t\tvar r = Std.random(2);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.rx + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(1 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tvar r1 = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;\n\t\t\tthis.rx = r1;\n\t\t\tthis.ry = r1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar circle = new geometrize_shape_Circle(this.xBound,this.yBound);\n\t\tcircle.x = this.x;\n\t\tcircle.y = this.y;\n\t\tcircle.rx = this.rx;\n\t\tcircle.ry = this.ry;\n\t\treturn circle;\n\t}\n\t,getType: function() {\n\t\treturn 5;\n\t}\n\t,getRawShapeData: function() {\n\t\treturn [this.x,this.y,this.rx];\n\t}\n\t,getSvgShapeData: function() {\n\t\treturn \"<circle cx=\\\"\" + this.x + \"\\\" cy=\\\"\" + this.y + \"\\\" r=\\\"\" + this.rx + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \" />\";\n\t}\n\t,__class__: geometrize_shape_Circle\n});\nvar geometrize_shape_Line = function(xBound,yBound) {\n\tthis.x1 = Std.random(xBound);\n\tthis.y1 = Std.random(yBound);\n\tvar value = this.x1 + Std.random(32) + 1;\n\tif(!(0 <= xBound)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tthis.x2 = value < 0 ? 0 : value > xBound ? xBound : value;\n\tvar value1 = this.y1 + Std.random(32) + 1;\n\tif(!(0 <= yBound)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tthis.y2 = value1 < 0 ? 0 : value1 > yBound ? yBound : value1;\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_Line.__name__ = true;\ngeometrize_shape_Line.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_Line.prototype = {\n\trasterize: function() {\n\t\tvar lines = [];\n\t\tvar points = geometrize_rasterizer_Rasterizer.bresenham(this.x1,this.y1,this.x2,this.y2);\n\t\tvar _g = 0;\n\t\twhile(_g < points.length) {\n\t\t\tvar point = points[_g];\n\t\t\t++_g;\n\t\t\tlines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));\n\t\t}\n\t\treturn geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);\n\t}\n\t,mutate: function() {\n\t\tvar r = Std.random(4);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x1 = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(0 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max3 = this.yBound - 1;\n\t\t\tif(!(0 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar line = new geometrize_shape_Line(this.xBound,this.yBound);\n\t\tline.x1 = this.x1;\n\t\tline.y1 = this.y1;\n\t\tline.x2 = this.x2;\n\t\tline.y2 = this.y2;\n\t\treturn line;\n\t}\n\t,getType: function() {\n\t\treturn 6;\n\t}\n\t,getRawShapeData: function() {\n\t\treturn [this.x1,this.y1,this.x2,this.y2];\n\t}\n\t,getSvgShapeData: function() {\n\t\treturn \"<line x1=\\\"\" + this.x1 + \"\\\" y1=\\\"\" + this.y1 + \"\\\" x2=\\\"\" + this.x2 + \"\\\" y2=\\\"\" + this.y2 + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \" />\";\n\t}\n\t,__class__: geometrize_shape_Line\n};\nvar geometrize_shape_QuadraticBezier = function(xBound,yBound) {\n\tvar upper = xBound - 1;\n\tif(!(0 <= upper)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.x1 = Math.floor((upper + 1) * Math.random());\n\tvar upper1 = yBound - 1;\n\tif(!(0 <= upper1)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.y1 = Math.floor((upper1 + 1) * Math.random());\n\tvar upper2 = xBound - 1;\n\tif(!(0 <= upper2)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.cx = Math.floor((upper2 + 1) * Math.random());\n\tvar upper3 = yBound - 1;\n\tif(!(0 <= upper3)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.cy = Math.floor((upper3 + 1) * Math.random());\n\tvar upper4 = xBound - 1;\n\tif(!(0 <= upper4)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.x2 = Math.floor((upper4 + 1) * Math.random());\n\tvar upper5 = yBound - 1;\n\tif(!(0 <= upper5)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.y2 = Math.floor((upper5 + 1) * Math.random());\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_QuadraticBezier.__name__ = true;\ngeometrize_shape_QuadraticBezier.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_QuadraticBezier.prototype = {\n\trasterize: function() {\n\t\tvar lines = [];\n\t\tvar points = [];\n\t\tvar pointCount = 20;\n\t\tvar _g1 = 0;\n\t\tvar _g = pointCount - 1;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tvar t = i / pointCount;\n\t\t\tvar tp = 1 - t;\n\t\t\tvar x = tp * (tp * this.x1 + t * this.cx) + t * (tp * this.cx + t * this.x2) | 0;\n\t\t\tvar y = tp * (tp * this.y1 + t * this.cy) + t * (tp * this.cy + t * this.y2) | 0;\n\t\t\tpoints.push({ x : x, y : y});\n\t\t}\n\t\tvar _g11 = 0;\n\t\tvar _g2 = points.length - 1;\n\t\twhile(_g11 < _g2) {\n\t\t\tvar i1 = _g11++;\n\t\t\tvar p0 = points[i1];\n\t\t\tvar p1 = points[i1 + 1];\n\t\t\tvar pts = geometrize_rasterizer_Rasterizer.bresenham(p0.x,p0.y,p1.x,p1.y);\n\t\t\tvar _g21 = 0;\n\t\t\twhile(_g21 < pts.length) {\n\t\t\t\tvar point = pts[_g21];\n\t\t\t\t++_g21;\n\t\t\t\tlines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));\n\t\t\t}\n\t\t}\n\t\treturn geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);\n\t}\n\t,mutate: function() {\n\t\tif(!true) {\n\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t}\n\t\tvar r = Math.floor(3 * Math.random());\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.cx + (-8 + Math.floor(17 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.cx = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.cy + (-8 + Math.floor(17 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.cy = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.x1 + (-8 + Math.floor(17 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(1 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x1 = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.y1 + (-8 + Math.floor(17 * Math.random()));\n\t\t\tvar max3 = this.yBound - 1;\n\t\t\tif(!(1 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y1 = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value4 = this.x2 + (-8 + Math.floor(17 * Math.random()));\n\t\t\tvar max4 = this.xBound - 1;\n\t\t\tif(!(1 <= max4)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x2 = value4 < 1 ? 1 : value4 > max4 ? max4 : value4;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value5 = this.y2 + (-8 + Math.floor(17 * Math.random()));\n\t\t\tvar max5 = this.yBound - 1;\n\t\t\tif(!(1 <= max5)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y2 = value5 < 1 ? 1 : value5 > max5 ? max5 : value5;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar bezier = new geometrize_shape_QuadraticBezier(this.xBound,this.yBound);\n\t\tbezier.cx = this.cx;\n\t\tbezier.cy = this.cy;\n\t\tbezier.x1 = this.x1;\n\t\tbezier.y1 = this.y1;\n\t\tbezier.x2 = this.x2;\n\t\tbezier.y2 = this.y2;\n\t\treturn bezier;\n\t}\n\t,getType: function() {\n\t\treturn 7;\n\t}\n\t,getRawShapeData: function() {\n\t\treturn [this.x1,this.y1,this.cx,this.cy,this.x2,this.y2];\n\t}\n\t,getSvgShapeData: function() {\n\t\treturn \"<path d=\\\"M\" + this.x1 + \" \" + this.y1 + \" Q \" + this.cx + \" \" + this.cy + \" \" + this.x2 + \" \" + this.y2 + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \" />\";\n\t}\n\t,__class__: geometrize_shape_QuadraticBezier\n};\nvar geometrize_shape_Rectangle = function(xBound,yBound) {\n\tthis.x1 = Std.random(xBound);\n\tthis.y1 = Std.random(yBound);\n\tvar value = this.x1 + Std.random(32) + 1;\n\tvar max = xBound - 1;\n\tif(!(0 <= max)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tthis.x2 = value < 0 ? 0 : value > max ? max : value;\n\tvar value1 = this.y1 + Std.random(32) + 1;\n\tvar max1 = yBound - 1;\n\tif(!(0 <= max1)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tthis.y2 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_Rectangle.__name__ = true;\ngeometrize_shape_Rectangle.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_Rectangle.prototype = {\n\trasterize: function() {\n\t\tvar lines = [];\n\t\tvar _g1 = this.y1;\n\t\tvar _g = this.y2;\n\t\twhile(_g1 < _g) {\n\t\t\tvar y = _g1++;\n\t\t\tif(this.x1 != this.x2) {\n\t\t\t\tvar first = this.x1;\n\t\t\t\tvar second = this.x2;\n\t\t\t\tvar first1 = this.x1;\n\t\t\t\tvar second1 = this.x2;\n\t\t\t\tlines.push(new geometrize_rasterizer_Scanline(y,first < second ? first : second,first1 > second1 ? first1 : second1));\n\t\t\t}\n\t\t}\n\t\treturn lines;\n\t}\n\t,mutate: function() {\n\t\tvar r = Std.random(2);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x1 = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(0 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max3 = this.yBound - 1;\n\t\t\tif(!(0 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar rectangle = new geometrize_shape_Rectangle(this.xBound,this.yBound);\n\t\trectangle.x1 = this.x1;\n\t\trectangle.y1 = this.y1;\n\t\trectangle.x2 = this.x2;\n\t\trectangle.y2 = this.y2;\n\t\treturn rectangle;\n\t}\n\t,getType: function() {\n\t\treturn 0;\n\t}\n\t,getRawShapeData: function() {\n\t\tvar first = this.x1;\n\t\tvar second = this.x2;\n\t\tvar first1 = this.y1;\n\t\tvar second1 = this.y2;\n\t\tvar first2 = this.x1;\n\t\tvar second2 = this.x2;\n\t\tvar first3 = this.y1;\n\t\tvar second3 = this.y2;\n\t\treturn [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3];\n\t}\n\t,getSvgShapeData: function() {\n\t\tvar first = this.x1;\n\t\tvar second = this.x2;\n\t\tvar first1 = this.y1;\n\t\tvar second1 = this.y2;\n\t\tvar first2 = this.x1;\n\t\tvar second2 = this.x2;\n\t\tvar first3 = this.x1;\n\t\tvar second3 = this.x2;\n\t\tvar first4 = this.y1;\n\t\tvar second4 = this.y2;\n\t\tvar first5 = this.y1;\n\t\tvar second5 = this.y2;\n\t\treturn \"<rect x=\\\"\" + (first < second ? first : second) + \"\\\" y=\\\"\" + (first1 < second1 ? first1 : second1) + \"\\\" width=\\\"\" + ((first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3)) + \"\\\" height=\\\"\" + ((first4 > second4 ? first4 : second4) - (first5 < second5 ? first5 : second5)) + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \" />\";\n\t}\n\t,__class__: geometrize_shape_Rectangle\n};\nvar geometrize_shape_RotatedEllipse = function(xBound,yBound) {\n\tthis.x = Std.random(xBound);\n\tthis.y = Std.random(yBound);\n\tthis.rx = Std.random(32) + 1;\n\tthis.ry = Std.random(32) + 1;\n\tthis.angle = Std.random(360);\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_RotatedEllipse.__name__ = true;\ngeometrize_shape_RotatedEllipse.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_RotatedEllipse.prototype = {\n\trasterize: function() {\n\t\tvar pointCount = 20;\n\t\tvar points = [];\n\t\tvar rads = this.angle * (Math.PI / 180.0);\n\t\tvar c = Math.cos(rads);\n\t\tvar s = Math.sin(rads);\n\t\tvar _g1 = 0;\n\t\tvar _g = pointCount;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tvar rot = 360.0 / pointCount * i * (Math.PI / 180.0);\n\t\t\tvar crx = this.rx * Math.cos(rot);\n\t\t\tvar cry = this.ry * Math.sin(rot);\n\t\t\tvar tx = crx * c - cry * s + this.x | 0;\n\t\t\tvar ty = crx * s + cry * c + this.y | 0;\n\t\t\tpoints.push({ x : tx, y : ty});\n\t\t}\n\t\treturn geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon(points),this.xBound,this.yBound);\n\t}\n\t,mutate: function() {\n\t\tvar r = Std.random(4);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.rx + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(1 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.rx = value2 < 1 ? 1 : value2 > max2 ? max2 : value2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.ry + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max3 = this.yBound - 1;\n\t\t\tif(!(1 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.ry = value3 < 1 ? 1 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value4 = this.angle + (-4 + Math.floor(9 * Math.random()));\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.angle = value4 < 0 ? 0 : value4 > 360 ? 360 : value4;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar ellipse = new geometrize_shape_RotatedEllipse(this.xBound,this.yBound);\n\t\tellipse.x = this.x;\n\t\tellipse.y = this.y;\n\t\tellipse.rx = this.rx;\n\t\tellipse.ry = this.ry;\n\t\tellipse.angle = this.angle;\n\t\treturn ellipse;\n\t}\n\t,getType: function() {\n\t\treturn 4;\n\t}\n\t,getRawShapeData: function() {\n\t\treturn [this.x,this.y,this.rx,this.ry,this.angle];\n\t}\n\t,getSvgShapeData: function() {\n\t\tvar s = \"<g transform=\\\"translate(\" + this.x + \" \" + this.y + \") rotate(\" + this.angle + \") scale(\" + this.rx + \" \" + this.ry + \")\\\">\";\n\t\ts += \"<ellipse cx=\\\"\" + 0 + \"\\\" cy=\\\"\" + 0 + \"\\\" rx=\\\"\" + 1 + \"\\\" ry=\\\"\" + 1 + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \" />\";\n\t\ts += \"</g>\";\n\t\treturn s;\n\t}\n\t,__class__: geometrize_shape_RotatedEllipse\n};\nvar geometrize_shape_RotatedRectangle = function(xBound,yBound) {\n\tthis.x1 = Std.random(xBound);\n\tthis.y1 = Std.random(yBound);\n\tvar value = this.x1 + Std.random(32) + 1;\n\tif(!(0 <= xBound)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tthis.x2 = value < 0 ? 0 : value > xBound ? xBound : value;\n\tvar value1 = this.y1 + Std.random(32) + 1;\n\tif(!(0 <= yBound)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t}\n\tthis.y2 = value1 < 0 ? 0 : value1 > yBound ? yBound : value1;\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.angle = Math.floor(361 * Math.random());\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_RotatedRectangle.__name__ = true;\ngeometrize_shape_RotatedRectangle.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_RotatedRectangle.prototype = {\n\trasterize: function() {\n\t\tvar first = this.x1;\n\t\tvar second = this.x2;\n\t\tvar xm1 = first < second ? first : second;\n\t\tvar first1 = this.x1;\n\t\tvar second1 = this.x2;\n\t\tvar xm2 = first1 > second1 ? first1 : second1;\n\t\tvar first2 = this.y1;\n\t\tvar second2 = this.y2;\n\t\tvar ym1 = first2 < second2 ? first2 : second2;\n\t\tvar first3 = this.y1;\n\t\tvar second3 = this.y2;\n\t\tvar ym2 = first3 > second3 ? first3 : second3;\n\t\tvar cx = (xm1 + xm2) / 2 | 0;\n\t\tvar cy = (ym1 + ym2) / 2 | 0;\n\t\tvar ox1 = xm1 - cx;\n\t\tvar ox2 = xm2 - cx;\n\t\tvar oy1 = ym1 - cy;\n\t\tvar oy2 = ym2 - cy;\n\t\tvar rads = this.angle * Math.PI / 180.0;\n\t\tvar c = Math.cos(rads);\n\t\tvar s = Math.sin(rads);\n\t\tvar ulx = ox1 * c - oy1 * s + cx | 0;\n\t\tvar uly = ox1 * s + oy1 * c + cy | 0;\n\t\tvar blx = ox1 * c - oy2 * s + cx | 0;\n\t\tvar bly = ox1 * s + oy2 * c + cy | 0;\n\t\tvar urx = ox2 * c - oy1 * s + cx | 0;\n\t\tvar ury = ox2 * s + oy1 * c + cy | 0;\n\t\tvar brx = ox2 * c - oy2 * s + cx | 0;\n\t\tvar bry = ox2 * s + oy2 * c + cy | 0;\n\t\treturn geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}]),this.xBound,this.yBound);\n\t}\n\t,mutate: function() {\n\t\tvar r = Std.random(3);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x1 = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(0 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max3 = this.yBound - 1;\n\t\t\tif(!(0 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value4 = this.angle + (-4 + Math.floor(9 * Math.random()));\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.angle = value4 < 0 ? 0 : value4 > 360 ? 360 : value4;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar rectangle = new geometrize_shape_RotatedRectangle(this.xBound,this.yBound);\n\t\trectangle.x1 = this.x1;\n\t\trectangle.y1 = this.y1;\n\t\trectangle.x2 = this.x2;\n\t\trectangle.y2 = this.y2;\n\t\trectangle.angle = this.angle;\n\t\treturn rectangle;\n\t}\n\t,getType: function() {\n\t\treturn 1;\n\t}\n\t,getRawShapeData: function() {\n\t\tvar first = this.x1;\n\t\tvar second = this.x2;\n\t\tvar first1 = this.y1;\n\t\tvar second1 = this.y2;\n\t\tvar first2 = this.x1;\n\t\tvar second2 = this.x2;\n\t\tvar first3 = this.y1;\n\t\tvar second3 = this.y2;\n\t\treturn [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3,this.angle];\n\t}\n\t,getSvgShapeData: function() {\n\t\tvar first = this.x1;\n\t\tvar second = this.x2;\n\t\tvar xm1 = first < second ? first : second;\n\t\tvar first1 = this.x1;\n\t\tvar second1 = this.x2;\n\t\tvar xm2 = first1 > second1 ? first1 : second1;\n\t\tvar first2 = this.y1;\n\t\tvar second2 = this.y2;\n\t\tvar ym1 = first2 < second2 ? first2 : second2;\n\t\tvar first3 = this.y1;\n\t\tvar second3 = this.y2;\n\t\tvar ym2 = first3 > second3 ? first3 : second3;\n\t\tvar cx = (xm1 + xm2) / 2 | 0;\n\t\tvar cy = (ym1 + ym2) / 2 | 0;\n\t\tvar ox1 = xm1 - cx;\n\t\tvar ox2 = xm2 - cx;\n\t\tvar oy1 = ym1 - cy;\n\t\tvar oy2 = ym2 - cy;\n\t\tvar rads = this.angle * Math.PI / 180.0;\n\t\tvar c = Math.cos(rads);\n\t\tvar s = Math.sin(rads);\n\t\tvar ulx = ox1 * c - oy1 * s + cx | 0;\n\t\tvar uly = ox1 * s + oy1 * c + cy | 0;\n\t\tvar blx = ox1 * c - oy2 * s + cx | 0;\n\t\tvar bly = ox1 * s + oy2 * c + cy | 0;\n\t\tvar urx = ox2 * c - oy1 * s + cx | 0;\n\t\tvar ury = ox2 * s + oy1 * c + cy | 0;\n\t\tvar brx = ox2 * c - oy2 * s + cx | 0;\n\t\tvar bry = ox2 * s + oy2 * c + cy | 0;\n\t\tvar points = [{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}];\n\t\tvar s1 = \"<polygon points=\\\"\";\n\t\tvar _g1 = 0;\n\t\tvar _g = points.length;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\ts1 += points[i].x + \" \" + points[i].y;\n\t\t\tif(i != points.length - 1) {\n\t\t\t\ts1 += \" \";\n\t\t\t}\n\t\t}\n\t\ts1 += \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \"/>\";\n\t\treturn s1;\n\t}\n\t,getCornerPoints: function() {\n\t\tvar first = this.x1;\n\t\tvar second = this.x2;\n\t\tvar xm1 = first < second ? first : second;\n\t\tvar first1 = this.x1;\n\t\tvar second1 = this.x2;\n\t\tvar xm2 = first1 > second1 ? first1 : second1;\n\t\tvar first2 = this.y1;\n\t\tvar second2 = this.y2;\n\t\tvar ym1 = first2 < second2 ? first2 : second2;\n\t\tvar first3 = this.y1;\n\t\tvar second3 = this.y2;\n\t\tvar ym2 = first3 > second3 ? first3 : second3;\n\t\tvar cx = (xm1 + xm2) / 2 | 0;\n\t\tvar cy = (ym1 + ym2) / 2 | 0;\n\t\tvar ox1 = xm1 - cx;\n\t\tvar ox2 = xm2 - cx;\n\t\tvar oy1 = ym1 - cy;\n\t\tvar oy2 = ym2 - cy;\n\t\tvar rads = this.angle * Math.PI / 180.0;\n\t\tvar c = Math.cos(rads);\n\t\tvar s = Math.sin(rads);\n\t\tvar ulx = ox1 * c - oy1 * s + cx | 0;\n\t\tvar uly = ox1 * s + oy1 * c + cy | 0;\n\t\tvar blx = ox1 * c - oy2 * s + cx | 0;\n\t\tvar bly = ox1 * s + oy2 * c + cy | 0;\n\t\tvar urx = ox2 * c - oy1 * s + cx | 0;\n\t\tvar ury = ox2 * s + oy1 * c + cy | 0;\n\t\tvar brx = ox2 * c - oy2 * s + cx | 0;\n\t\tvar bry = ox2 * s + oy2 * c + cy | 0;\n\t\treturn [{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}];\n\t}\n\t,__class__: geometrize_shape_RotatedRectangle\n};\nvar geometrize_shape_ShapeFactory = function() { };\ngeometrize_shape_ShapeFactory.__name__ = true;\ngeometrize_shape_ShapeFactory.create = function(type,xBound,yBound) {\n\tswitch(type) {\n\tcase 0:\n\t\treturn new geometrize_shape_Rectangle(xBound,yBound);\n\tcase 1:\n\t\treturn new geometrize_shape_RotatedRectangle(xBound,yBound);\n\tcase 2:\n\t\treturn new geometrize_shape_Triangle(xBound,yBound);\n\tcase 3:\n\t\treturn new geometrize_shape_Ellipse(xBound,yBound);\n\tcase 4:\n\t\treturn new geometrize_shape_RotatedEllipse(xBound,yBound);\n\tcase 5:\n\t\treturn new geometrize_shape_Circle(xBound,yBound);\n\tcase 6:\n\t\treturn new geometrize_shape_Line(xBound,yBound);\n\tcase 7:\n\t\treturn new geometrize_shape_QuadraticBezier(xBound,yBound);\n\t}\n};\ngeometrize_shape_ShapeFactory.randomShape = function(xBound,yBound) {\n\tvar a = [0,1,2,3,4,5,6,7];\n\tif(!(a != null && a.length > 0)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: a != null && a.length > 0\");\n\t}\n\tvar upper = a.length - 1;\n\tif(!(0 <= upper)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\treturn geometrize_shape_ShapeFactory.create(a[Math.floor((upper + 1) * Math.random())],xBound,yBound);\n};\ngeometrize_shape_ShapeFactory.randomShapeOf = function(types,xBound,yBound) {\n\tif(!(types != null && types.length > 0)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: a != null && a.length > 0\");\n\t}\n\tvar upper = types.length - 1;\n\tif(!(0 <= upper)) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\treturn geometrize_shape_ShapeFactory.create(types[Math.floor((upper + 1) * Math.random())],xBound,yBound);\n};\nvar geometrize_shape_ShapeTypes = $hx_exports[\"geometrize\"][\"shape\"][\"ShapeTypes\"] = function() { };\ngeometrize_shape_ShapeTypes.__name__ = true;\nvar geometrize_shape_Triangle = function(xBound,yBound) {\n\tthis.x1 = Std.random(xBound);\n\tthis.y1 = Std.random(yBound);\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.x2 = this.x1 + (-16 + Math.floor(33 * Math.random()));\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.y2 = this.y1 + (-16 + Math.floor(33 * Math.random()));\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.x3 = this.x1 + (-16 + Math.floor(33 * Math.random()));\n\tif(!true) {\n\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t}\n\tthis.y3 = this.y1 + (-16 + Math.floor(33 * Math.random()));\n\tthis.xBound = xBound;\n\tthis.yBound = yBound;\n};\ngeometrize_shape_Triangle.__name__ = true;\ngeometrize_shape_Triangle.__interfaces__ = [geometrize_shape_Shape];\ngeometrize_shape_Triangle.prototype = {\n\trasterize: function() {\n\t\treturn geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : this.x1, y : this.y1},{ x : this.x2, y : this.y2},{ x : this.x3, y : this.y3}]),this.xBound,this.yBound);\n\t}\n\t,mutate: function() {\n\t\tvar r = Std.random(3);\n\t\tswitch(r) {\n\t\tcase 0:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value = this.x1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max = this.xBound - 1;\n\t\t\tif(!(0 <= max)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x1 = value < 0 ? 0 : value > max ? max : value;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value1 = this.y1 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max1 = this.yBound - 1;\n\t\t\tif(!(0 <= max1)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y1 = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value2 = this.x2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max2 = this.xBound - 1;\n\t\t\tif(!(0 <= max2)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x2 = value2 < 0 ? 0 : value2 > max2 ? max2 : value2;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value3 = this.y2 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max3 = this.yBound - 1;\n\t\t\tif(!(0 <= max3)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y2 = value3 < 0 ? 0 : value3 > max3 ? max3 : value3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value4 = this.x3 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max4 = this.xBound - 1;\n\t\t\tif(!(0 <= max4)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.x3 = value4 < 0 ? 0 : value4 > max4 ? max4 : value4;\n\t\t\tif(!true) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: lower <= upper\");\n\t\t\t}\n\t\t\tvar value5 = this.y3 + (-16 + Math.floor(33 * Math.random()));\n\t\t\tvar max5 = this.yBound - 1;\n\t\t\tif(!(0 <= max5)) {\n\t\t\t\tthrow new js__$Boot_HaxeError(\"FAIL: min <= max\");\n\t\t\t}\n\t\t\tthis.y3 = value5 < 0 ? 0 : value5 > max5 ? max5 : value5;\n\t\t\tbreak;\n\t\t}\n\t}\n\t,clone: function() {\n\t\tvar triangle = new geometrize_shape_Triangle(this.xBound,this.yBound);\n\t\ttriangle.x1 = this.x1;\n\t\ttriangle.y1 = this.y1;\n\t\ttriangle.x2 = this.x2;\n\t\ttriangle.y2 = this.y2;\n\t\ttriangle.x3 = this.x3;\n\t\ttriangle.y3 = this.y3;\n\t\treturn triangle;\n\t}\n\t,getType: function() {\n\t\treturn 2;\n\t}\n\t,getRawShapeData: function() {\n\t\treturn [this.x1,this.y1,this.x2,this.y2,this.x3,this.y3];\n\t}\n\t,getSvgShapeData: function() {\n\t\treturn \"<polygon points=\\\"\" + this.x1 + \",\" + this.y1 + \" \" + this.x2 + \",\" + this.y2 + \" \" + this.x3 + \",\" + this.y3 + \"\\\" \" + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + \"/>\";\n\t}\n\t,__class__: geometrize_shape_Triangle\n};\nvar haxe_IMap = function() { };\nhaxe_IMap.__name__ = true;\nvar haxe_ds_IntMap = function() {\n\tthis.h = { };\n};\nhaxe_ds_IntMap.__name__ = true;\nhaxe_ds_IntMap.__interfaces__ = [haxe_IMap];\nhaxe_ds_IntMap.prototype = {\n\tkeys: function() {\n\t\tvar a = [];\n\t\tfor( var key in this.h ) if(this.h.hasOwnProperty(key)) {\n\t\t\ta.push(key | 0);\n\t\t}\n\t\treturn HxOverrides.iter(a);\n\t}\n\t,__class__: haxe_ds_IntMap\n};\nvar haxe_io_Bytes = function(data) {\n\tthis.length = data.byteLength;\n\tthis.b = new Uint8Array(data);\n\tthis.b.bufferValue = data;\n\tdata.hxBytes = this;\n\tdata.bytes = this.b;\n};\nhaxe_io_Bytes.__name__ = true;\nhaxe_io_Bytes.prototype = {\n\t__class__: haxe_io_Bytes\n};\nvar js__$Boot_HaxeError = function(val) {\n\tError.call(this);\n\tthis.val = val;\n\tthis.message = String(val);\n\tif(Error.captureStackTrace) {\n\t\tError.captureStackTrace(this,js__$Boot_HaxeError);\n\t}\n};\njs__$Boot_HaxeError.__name__ = true;\njs__$Boot_HaxeError.wrap = function(val) {\n\tif((val instanceof Error)) {\n\t\treturn val;\n\t} else {\n\t\treturn new js__$Boot_HaxeError(val);\n\t}\n};\njs__$Boot_HaxeError.__super__ = Error;\njs__$Boot_HaxeError.prototype = $extend(Error.prototype,{\n\t__class__: js__$Boot_HaxeError\n});\nvar js_Boot = function() { };\njs_Boot.__name__ = true;\njs_Boot.getClass = function(o) {\n\tif((o instanceof Array) && o.__enum__ == null) {\n\t\treturn Array;\n\t} else {\n\t\tvar cl = o.__class__;\n\t\tif(cl != null) {\n\t\t\treturn cl;\n\t\t}\n\t\tvar name = js_Boot.__nativeClassName(o);\n\t\tif(name != null) {\n\t\t\treturn js_Boot.__resolveNativeClass(name);\n\t\t}\n\t\treturn null;\n\t}\n};\njs_Boot.__string_rec = function(o,s) {\n\tif(o == null) {\n\t\treturn \"null\";\n\t}\n\tif(s.length >= 5) {\n\t\treturn \"<...>\";\n\t}\n\tvar t = typeof(o);\n\tif(t == \"function\" && (o.__name__ || o.__ename__)) {\n\t\tt = \"object\";\n\t}\n\tswitch(t) {\n\tcase \"function\":\n\t\treturn \"<function>\";\n\tcase \"object\":\n\t\tif(o instanceof Array) {\n\t\t\tif(o.__enum__) {\n\t\t\t\tif(o.length == 2) {\n\t\t\t\t\treturn o[0];\n\t\t\t\t}\n\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar _g1 = 2;\n\t\t\t\tvar _g = o.length;\n\t\t\t\twhile(_g1 < _g) {\n\t\t\t\t\tvar i = _g1++;\n\t\t\t\t\tif(i != 2) {\n\t\t\t\t\t\tstr += \",\" + js_Boot.__string_rec(o[i],s);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr += js_Boot.__string_rec(o[i],s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn str + \")\";\n\t\t\t}\n\t\t\tvar l = o.length;\n\t\t\tvar i1;\n\t\t\tvar str1 = \"[\";\n\t\t\ts += \"\\t\";\n\t\t\tvar _g11 = 0;\n\t\t\tvar _g2 = l;\n\t\t\twhile(_g11 < _g2) {\n\t\t\t\tvar i2 = _g11++;\n\t\t\t\tstr1 += (i2 > 0 ? \",\" : \"\") + js_Boot.__string_rec(o[i2],s);\n\t\t\t}\n\t\t\tstr1 += \"]\";\n\t\t\treturn str1;\n\t\t}\n\t\tvar tostr;\n\t\ttry {\n\t\t\ttostr = o.toString;\n\t\t} catch( e ) {\n\t\t\treturn \"???\";\n\t\t}\n\t\tif(tostr != null && tostr != Object.toString && typeof(tostr) == \"function\") {\n\t\t\tvar s2 = o.toString();\n\t\t\tif(s2 != \"[object Object]\") {\n\t\t\t\treturn s2;\n\t\t\t}\n\t\t}\n\t\tvar k = null;\n\t\tvar str2 = \"{\\n\";\n\t\ts += \"\\t\";\n\t\tvar hasp = o.hasOwnProperty != null;\n\t\tfor( var k in o ) {\n\t\tif(hasp && !o.hasOwnProperty(k)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif(str2.length != 2) {\n\t\t\tstr2 += \", \\n\";\n\t\t}\n\t\tstr2 += s + k + \" : \" + js_Boot.__string_rec(o[k],s);\n\t\t}\n\t\ts = s.substring(1);\n\t\tstr2 += \"\\n\" + s + \"}\";\n\t\treturn str2;\n\tcase \"string\":\n\t\treturn o;\n\tdefault:\n\t\treturn String(o);\n\t}\n};\njs_Boot.__interfLoop = function(cc,cl) {\n\tif(cc == null) {\n\t\treturn false;\n\t}\n\tif(cc == cl) {\n\t\treturn true;\n\t}\n\tvar intf = cc.__interfaces__;\n\tif(intf != null) {\n\t\tvar _g1 = 0;\n\t\tvar _g = intf.length;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tvar i1 = intf[i];\n\t\t\tif(i1 == cl || js_Boot.__interfLoop(i1,cl)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn js_Boot.__interfLoop(cc.__super__,cl);\n};\njs_Boot.__instanceof = function(o,cl) {\n\tif(cl == null) {\n\t\treturn false;\n\t}\n\tswitch(cl) {\n\tcase Array:\n\t\tif((o instanceof Array)) {\n\t\t\treturn o.__enum__ == null;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase Bool:\n\t\treturn typeof(o) == \"boolean\";\n\tcase Dynamic:\n\t\treturn true;\n\tcase Float:\n\t\treturn typeof(o) == \"number\";\n\tcase Int:\n\t\tif(typeof(o) == \"number\") {\n\t\t\treturn (o|0) === o;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase String:\n\t\treturn typeof(o) == \"string\";\n\tdefault:\n\t\tif(o != null) {\n\t\t\tif(typeof(cl) == \"function\") {\n\t\t\t\tif(o instanceof cl) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if(typeof(cl) == \"object\" && js_Boot.__isNativeObj(cl)) {\n\t\t\t\tif(o instanceof cl) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tif(cl == Class ? o.__name__ != null : false) {\n\t\t\treturn true;\n\t\t}\n\t\tif(cl == Enum ? o.__ename__ != null : false) {\n\t\t\treturn true;\n\t\t}\n\t\treturn o.__enum__ == cl;\n\t}\n};\njs_Boot.__nativeClassName = function(o) {\n\tvar name = js_Boot.__toStr.call(o).slice(8,-1);\n\tif(name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\") {\n\t\treturn null;\n\t}\n\treturn name;\n};\njs_Boot.__isNativeObj = function(o) {\n\treturn js_Boot.__nativeClassName(o) != null;\n};\njs_Boot.__resolveNativeClass = function(name) {\n\treturn $global[name];\n};\nvar js_html_compat_ArrayBuffer = function(a) {\n\tif((a instanceof Array) && a.__enum__ == null) {\n\t\tthis.a = a;\n\t\tthis.byteLength = a.length;\n\t} else {\n\t\tvar len = a;\n\t\tthis.a = [];\n\t\tvar _g1 = 0;\n\t\tvar _g = len;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tthis.a[i] = 0;\n\t\t}\n\t\tthis.byteLength = len;\n\t}\n};\njs_html_compat_ArrayBuffer.__name__ = true;\njs_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {\n\tvar u = new Uint8Array(this,begin,end == null ? null : end - begin);\n\tvar result = new ArrayBuffer(u.byteLength);\n\tvar resultArray = new Uint8Array(result);\n\tresultArray.set(u);\n\treturn result;\n};\njs_html_compat_ArrayBuffer.prototype = {\n\tslice: function(begin,end) {\n\t\treturn new js_html_compat_ArrayBuffer(this.a.slice(begin,end));\n\t}\n\t,__class__: js_html_compat_ArrayBuffer\n};\nvar js_html_compat_Uint8Array = function() { };\njs_html_compat_Uint8Array.__name__ = true;\njs_html_compat_Uint8Array._new = function(arg1,offset,length) {\n\tvar arr;\n\tif(typeof(arg1) == \"number\") {\n\t\tarr = [];\n\t\tvar _g1 = 0;\n\t\tvar _g = arg1;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tarr[i] = 0;\n\t\t}\n\t\tarr.byteLength = arr.length;\n\t\tarr.byteOffset = 0;\n\t\tarr.buffer = new js_html_compat_ArrayBuffer(arr);\n\t} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {\n\t\tvar buffer = arg1;\n\t\tif(offset == null) {\n\t\t\toffset = 0;\n\t\t}\n\t\tif(length == null) {\n\t\t\tlength = buffer.byteLength - offset;\n\t\t}\n\t\tif(offset == 0) {\n\t\t\tarr = buffer.a;\n\t\t} else {\n\t\t\tarr = buffer.a.slice(offset,offset + length);\n\t\t}\n\t\tarr.byteLength = arr.length;\n\t\tarr.byteOffset = offset;\n\t\tarr.buffer = buffer;\n\t} else if((arg1 instanceof Array) && arg1.__enum__ == null) {\n\t\tarr = arg1.slice();\n\t\tarr.byteLength = arr.length;\n\t\tarr.byteOffset = 0;\n\t\tarr.buffer = new js_html_compat_ArrayBuffer(arr);\n\t} else {\n\t\tthrow new js__$Boot_HaxeError(\"TODO \" + Std.string(arg1));\n\t}\n\tarr.subarray = js_html_compat_Uint8Array._subarray;\n\tarr.set = js_html_compat_Uint8Array._set;\n\treturn arr;\n};\njs_html_compat_Uint8Array._set = function(arg,offset) {\n\tif(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {\n\t\tvar a = arg;\n\t\tif(arg.byteLength + offset > this.byteLength) {\n\t\t\tthrow new js__$Boot_HaxeError(\"set() outside of range\");\n\t\t}\n\t\tvar _g1 = 0;\n\t\tvar _g = arg.byteLength;\n\t\twhile(_g1 < _g) {\n\t\t\tvar i = _g1++;\n\t\t\tthis[i + offset] = a[i];\n\t\t}\n\t} else if((arg instanceof Array) && arg.__enum__ == null) {\n\t\tvar a1 = arg;\n\t\tif(a1.length + offset > this.byteLength) {\n\t\t\tthrow new js__$Boot_HaxeError(\"set() outside of range\");\n\t\t}\n\t\tvar _g11 = 0;\n\t\tvar _g2 = a1.length;\n\t\twhile(_g11 < _g2) {\n\t\t\tvar i1 = _g11++;\n\t\t\tthis[i1 + offset] = a1[i1];\n\t\t}\n\t} else {\n\t\tthrow new js__$Boot_HaxeError(\"TODO\");\n\t}\n};\njs_html_compat_Uint8Array._subarray = function(start,end) {\n\tvar a = js_html_compat_Uint8Array._new(this.slice(start,end));\n\ta.byteOffset = start;\n\treturn a;\n};\nString.prototype.__class__ = String;\nString.__name__ = true;\nArray.__name__ = true;\nvar Int = { __name__ : [\"Int\"]};\nvar Dynamic = { __name__ : [\"Dynamic\"]};\nvar Float = Number;\nFloat.__name__ = [\"Float\"];\nvar Bool = Boolean;\nBool.__ename__ = [\"Bool\"];\nvar Class = { __name__ : [\"Class\"]};\nvar Enum = { };\nvar ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;\nif(ArrayBuffer.prototype.slice == null) {\n\tArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;\n}\nvar Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;\ngeometrize_exporter_SvgExporter.SVG_STYLE_HOOK = \"::svg_style_hook::\";\ngeometrize_shape_ShapeTypes.RECTANGLE = 0;\ngeometrize_shape_ShapeTypes.ROTATED_RECTANGLE = 1;\ngeometrize_shape_ShapeTypes.TRIANGLE = 2;\ngeometrize_shape_ShapeTypes.ELLIPSE = 3;\ngeometrize_shape_ShapeTypes.ROTATED_ELLIPSE = 4;\ngeometrize_shape_ShapeTypes.CIRCLE = 5;\ngeometrize_shape_ShapeTypes.LINE = 6;\ngeometrize_shape_ShapeTypes.QUADRATIC_BEZIER = 7;\njs_Boot.__toStr = ({ }).toString;\njs_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;\n})(typeof exports != \"undefined\" ? exports : typeof window != \"undefined\" ? window : typeof self != \"undefined\" ? self : this, typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this);\n"]}